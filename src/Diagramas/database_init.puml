@startuml database init
hide footbox

participant Server order 10
participant Database order 20

Create Database
Server -> Database++: new()

participant Channel as "ttl_sender: Sender<MessageTtl>,\n ttl_rec: Receiver<MessageTtl>" order 40 
Create Channel
Database -> Channel: mpsc::channel()

Database -> Database: Database {\n\tdictionary: Arc<Mutex<HashMap>>,\n\tttl_sender\n}
Database -> Database ++: ttl_supervisor_run(ttl_rec)

group Thread:
    participant ttl_keys as "ttl_keys: Arc<Mutex<Vec<KeyTtl>>>" order 25
    create ttl_keys
    Database -> ttl_keys: new()
    loop for message in ttl_rec
        alt MessageTtl::Expire(new_key_ttl: Key_ttl)
            Database -> ttl_keys++: lock()
            Database -> ttl_keys: binary_search(&new_key_ttl)
            return pos

            Database -> ttl_keys ++: insert(pos, new_key_ttl)
            deactivate ttl_keys

            Database -> ttl_keys ++: len()
            return len

            alt len == 1
                group thread
                    Database -> Database++: executor(dictionary, tttl_vector)
                    deactivate Database
                end
            end
        else MessageTtl::Clear(key: String)
            Database -> ttl_keys++: lock()
            Database -> ttl_keys: iter().position(|x| x.key == key) {\n\tkeys_locked.remove(pos);\n}
            deactivate ttl_keys
        else MessageTtl::Transfer(from_key: String, to_key: String)
            Database -> ttl_keys++: lock()
            Database -> ttl_keys: iter().position(|x| x.key == key) {\n\tlet ttl = keys_locked.get_mut(pos).unwrap();\n\tttl.key = to_key;\n}
            deactivate ttl_keys
        else MessageTtl::TTL(key: String, sender_respond: Sender<RespondTtl>)
            Database -> ttl_keys++: lock()
            Database -> ttl_keys: iter().position(|x| x.key == key)
            return Option

            alt Option == Some(pos)
                Database -> ttl_keys ++: get(pos)
                return keyttl
                create sender_respond
                Database -> sender_respond ++: send(RespondTtl::TTL(keyttl.expire_time))
                deactivate sender_respond
            else 
                Database -> sender_respond ++: sender_respond.send(RespondTtl::Persistent).unwrap();
            end
        end
    end
end

@enduml